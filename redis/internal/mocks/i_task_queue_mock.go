// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i task-queue/internal/queue.ITaskQueue -o i_task_queue_mock_test.go -n ITaskQueueMock -p queue

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ITaskQueueMock implements ITaskQueue
type ITaskQueueMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddTask          func(ctx context.Context, payload string, priority int, executeAt time.Time) (err error)
	funcAddTaskOrigin    string
	inspectFuncAddTask   func(ctx context.Context, payload string, priority int, executeAt time.Time)
	afterAddTaskCounter  uint64
	beforeAddTaskCounter uint64
	AddTaskMock          mITaskQueueMockAddTask

	funcProcessTasks          func(ctx context.Context)
	funcProcessTasksOrigin    string
	inspectFuncProcessTasks   func(ctx context.Context)
	afterProcessTasksCounter  uint64
	beforeProcessTasksCounter uint64
	ProcessTasksMock          mITaskQueueMockProcessTasks
}

// NewITaskQueueMock returns a mock for ITaskQueue
func NewITaskQueueMock(t minimock.Tester) *ITaskQueueMock {
	m := &ITaskQueueMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddTaskMock = mITaskQueueMockAddTask{mock: m}
	m.AddTaskMock.callArgs = []*ITaskQueueMockAddTaskParams{}

	m.ProcessTasksMock = mITaskQueueMockProcessTasks{mock: m}
	m.ProcessTasksMock.callArgs = []*ITaskQueueMockProcessTasksParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mITaskQueueMockAddTask struct {
	optional           bool
	mock               *ITaskQueueMock
	defaultExpectation *ITaskQueueMockAddTaskExpectation
	expectations       []*ITaskQueueMockAddTaskExpectation

	callArgs []*ITaskQueueMockAddTaskParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITaskQueueMockAddTaskExpectation specifies expectation struct of the ITaskQueue.AddTask
type ITaskQueueMockAddTaskExpectation struct {
	mock               *ITaskQueueMock
	params             *ITaskQueueMockAddTaskParams
	paramPtrs          *ITaskQueueMockAddTaskParamPtrs
	expectationOrigins ITaskQueueMockAddTaskExpectationOrigins
	results            *ITaskQueueMockAddTaskResults
	returnOrigin       string
	Counter            uint64
}

// ITaskQueueMockAddTaskParams contains parameters of the ITaskQueue.AddTask
type ITaskQueueMockAddTaskParams struct {
	ctx       context.Context
	payload   string
	priority  int
	executeAt time.Time
}

// ITaskQueueMockAddTaskParamPtrs contains pointers to parameters of the ITaskQueue.AddTask
type ITaskQueueMockAddTaskParamPtrs struct {
	ctx       *context.Context
	payload   *string
	priority  *int
	executeAt *time.Time
}

// ITaskQueueMockAddTaskResults contains results of the ITaskQueue.AddTask
type ITaskQueueMockAddTaskResults struct {
	err error
}

// ITaskQueueMockAddTaskOrigins contains origins of expectations of the ITaskQueue.AddTask
type ITaskQueueMockAddTaskExpectationOrigins struct {
	origin          string
	originCtx       string
	originPayload   string
	originPriority  string
	originExecuteAt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddTask *mITaskQueueMockAddTask) Optional() *mITaskQueueMockAddTask {
	mmAddTask.optional = true
	return mmAddTask
}

// Expect sets up expected params for ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) Expect(ctx context.Context, payload string, priority int, executeAt time.Time) *mITaskQueueMockAddTask {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	if mmAddTask.defaultExpectation == nil {
		mmAddTask.defaultExpectation = &ITaskQueueMockAddTaskExpectation{}
	}

	if mmAddTask.defaultExpectation.paramPtrs != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by ExpectParams functions")
	}

	mmAddTask.defaultExpectation.params = &ITaskQueueMockAddTaskParams{ctx, payload, priority, executeAt}
	mmAddTask.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddTask.expectations {
		if minimock.Equal(e.params, mmAddTask.defaultExpectation.params) {
			mmAddTask.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddTask.defaultExpectation.params)
		}
	}

	return mmAddTask
}

// ExpectCtxParam1 sets up expected param ctx for ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) ExpectCtxParam1(ctx context.Context) *mITaskQueueMockAddTask {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	if mmAddTask.defaultExpectation == nil {
		mmAddTask.defaultExpectation = &ITaskQueueMockAddTaskExpectation{}
	}

	if mmAddTask.defaultExpectation.params != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Expect")
	}

	if mmAddTask.defaultExpectation.paramPtrs == nil {
		mmAddTask.defaultExpectation.paramPtrs = &ITaskQueueMockAddTaskParamPtrs{}
	}
	mmAddTask.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddTask.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddTask
}

// ExpectPayloadParam2 sets up expected param payload for ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) ExpectPayloadParam2(payload string) *mITaskQueueMockAddTask {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	if mmAddTask.defaultExpectation == nil {
		mmAddTask.defaultExpectation = &ITaskQueueMockAddTaskExpectation{}
	}

	if mmAddTask.defaultExpectation.params != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Expect")
	}

	if mmAddTask.defaultExpectation.paramPtrs == nil {
		mmAddTask.defaultExpectation.paramPtrs = &ITaskQueueMockAddTaskParamPtrs{}
	}
	mmAddTask.defaultExpectation.paramPtrs.payload = &payload
	mmAddTask.defaultExpectation.expectationOrigins.originPayload = minimock.CallerInfo(1)

	return mmAddTask
}

// ExpectPriorityParam3 sets up expected param priority for ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) ExpectPriorityParam3(priority int) *mITaskQueueMockAddTask {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	if mmAddTask.defaultExpectation == nil {
		mmAddTask.defaultExpectation = &ITaskQueueMockAddTaskExpectation{}
	}

	if mmAddTask.defaultExpectation.params != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Expect")
	}

	if mmAddTask.defaultExpectation.paramPtrs == nil {
		mmAddTask.defaultExpectation.paramPtrs = &ITaskQueueMockAddTaskParamPtrs{}
	}
	mmAddTask.defaultExpectation.paramPtrs.priority = &priority
	mmAddTask.defaultExpectation.expectationOrigins.originPriority = minimock.CallerInfo(1)

	return mmAddTask
}

// ExpectExecuteAtParam4 sets up expected param executeAt for ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) ExpectExecuteAtParam4(executeAt time.Time) *mITaskQueueMockAddTask {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	if mmAddTask.defaultExpectation == nil {
		mmAddTask.defaultExpectation = &ITaskQueueMockAddTaskExpectation{}
	}

	if mmAddTask.defaultExpectation.params != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Expect")
	}

	if mmAddTask.defaultExpectation.paramPtrs == nil {
		mmAddTask.defaultExpectation.paramPtrs = &ITaskQueueMockAddTaskParamPtrs{}
	}
	mmAddTask.defaultExpectation.paramPtrs.executeAt = &executeAt
	mmAddTask.defaultExpectation.expectationOrigins.originExecuteAt = minimock.CallerInfo(1)

	return mmAddTask
}

// Inspect accepts an inspector function that has same arguments as the ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) Inspect(f func(ctx context.Context, payload string, priority int, executeAt time.Time)) *mITaskQueueMockAddTask {
	if mmAddTask.mock.inspectFuncAddTask != nil {
		mmAddTask.mock.t.Fatalf("Inspect function is already set for ITaskQueueMock.AddTask")
	}

	mmAddTask.mock.inspectFuncAddTask = f

	return mmAddTask
}

// Return sets up results that will be returned by ITaskQueue.AddTask
func (mmAddTask *mITaskQueueMockAddTask) Return(err error) *ITaskQueueMock {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	if mmAddTask.defaultExpectation == nil {
		mmAddTask.defaultExpectation = &ITaskQueueMockAddTaskExpectation{mock: mmAddTask.mock}
	}
	mmAddTask.defaultExpectation.results = &ITaskQueueMockAddTaskResults{err}
	mmAddTask.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddTask.mock
}

// Set uses given function f to mock the ITaskQueue.AddTask method
func (mmAddTask *mITaskQueueMockAddTask) Set(f func(ctx context.Context, payload string, priority int, executeAt time.Time) (err error)) *ITaskQueueMock {
	if mmAddTask.defaultExpectation != nil {
		mmAddTask.mock.t.Fatalf("Default expectation is already set for the ITaskQueue.AddTask method")
	}

	if len(mmAddTask.expectations) > 0 {
		mmAddTask.mock.t.Fatalf("Some expectations are already set for the ITaskQueue.AddTask method")
	}

	mmAddTask.mock.funcAddTask = f
	mmAddTask.mock.funcAddTaskOrigin = minimock.CallerInfo(1)
	return mmAddTask.mock
}

// When sets expectation for the ITaskQueue.AddTask which will trigger the result defined by the following
// Then helper
func (mmAddTask *mITaskQueueMockAddTask) When(ctx context.Context, payload string, priority int, executeAt time.Time) *ITaskQueueMockAddTaskExpectation {
	if mmAddTask.mock.funcAddTask != nil {
		mmAddTask.mock.t.Fatalf("ITaskQueueMock.AddTask mock is already set by Set")
	}

	expectation := &ITaskQueueMockAddTaskExpectation{
		mock:               mmAddTask.mock,
		params:             &ITaskQueueMockAddTaskParams{ctx, payload, priority, executeAt},
		expectationOrigins: ITaskQueueMockAddTaskExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddTask.expectations = append(mmAddTask.expectations, expectation)
	return expectation
}

// Then sets up ITaskQueue.AddTask return parameters for the expectation previously defined by the When method
func (e *ITaskQueueMockAddTaskExpectation) Then(err error) *ITaskQueueMock {
	e.results = &ITaskQueueMockAddTaskResults{err}
	return e.mock
}

// Times sets number of times ITaskQueue.AddTask should be invoked
func (mmAddTask *mITaskQueueMockAddTask) Times(n uint64) *mITaskQueueMockAddTask {
	if n == 0 {
		mmAddTask.mock.t.Fatalf("Times of ITaskQueueMock.AddTask mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddTask.expectedInvocations, n)
	mmAddTask.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddTask
}

func (mmAddTask *mITaskQueueMockAddTask) invocationsDone() bool {
	if len(mmAddTask.expectations) == 0 && mmAddTask.defaultExpectation == nil && mmAddTask.mock.funcAddTask == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddTask.mock.afterAddTaskCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddTask.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddTask implements ITaskQueue
func (mmAddTask *ITaskQueueMock) AddTask(ctx context.Context, payload string, priority int, executeAt time.Time) (err error) {
	mm_atomic.AddUint64(&mmAddTask.beforeAddTaskCounter, 1)
	defer mm_atomic.AddUint64(&mmAddTask.afterAddTaskCounter, 1)

	mmAddTask.t.Helper()

	if mmAddTask.inspectFuncAddTask != nil {
		mmAddTask.inspectFuncAddTask(ctx, payload, priority, executeAt)
	}

	mm_params := ITaskQueueMockAddTaskParams{ctx, payload, priority, executeAt}

	// Record call args
	mmAddTask.AddTaskMock.mutex.Lock()
	mmAddTask.AddTaskMock.callArgs = append(mmAddTask.AddTaskMock.callArgs, &mm_params)
	mmAddTask.AddTaskMock.mutex.Unlock()

	for _, e := range mmAddTask.AddTaskMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddTask.AddTaskMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddTask.AddTaskMock.defaultExpectation.Counter, 1)
		mm_want := mmAddTask.AddTaskMock.defaultExpectation.params
		mm_want_ptrs := mmAddTask.AddTaskMock.defaultExpectation.paramPtrs

		mm_got := ITaskQueueMockAddTaskParams{ctx, payload, priority, executeAt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddTask.t.Errorf("ITaskQueueMock.AddTask got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTask.AddTaskMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.payload != nil && !minimock.Equal(*mm_want_ptrs.payload, mm_got.payload) {
				mmAddTask.t.Errorf("ITaskQueueMock.AddTask got unexpected parameter payload, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTask.AddTaskMock.defaultExpectation.expectationOrigins.originPayload, *mm_want_ptrs.payload, mm_got.payload, minimock.Diff(*mm_want_ptrs.payload, mm_got.payload))
			}

			if mm_want_ptrs.priority != nil && !minimock.Equal(*mm_want_ptrs.priority, mm_got.priority) {
				mmAddTask.t.Errorf("ITaskQueueMock.AddTask got unexpected parameter priority, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTask.AddTaskMock.defaultExpectation.expectationOrigins.originPriority, *mm_want_ptrs.priority, mm_got.priority, minimock.Diff(*mm_want_ptrs.priority, mm_got.priority))
			}

			if mm_want_ptrs.executeAt != nil && !minimock.Equal(*mm_want_ptrs.executeAt, mm_got.executeAt) {
				mmAddTask.t.Errorf("ITaskQueueMock.AddTask got unexpected parameter executeAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddTask.AddTaskMock.defaultExpectation.expectationOrigins.originExecuteAt, *mm_want_ptrs.executeAt, mm_got.executeAt, minimock.Diff(*mm_want_ptrs.executeAt, mm_got.executeAt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddTask.t.Errorf("ITaskQueueMock.AddTask got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddTask.AddTaskMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddTask.AddTaskMock.defaultExpectation.results
		if mm_results == nil {
			mmAddTask.t.Fatal("No results are set for the ITaskQueueMock.AddTask")
		}
		return (*mm_results).err
	}
	if mmAddTask.funcAddTask != nil {
		return mmAddTask.funcAddTask(ctx, payload, priority, executeAt)
	}
	mmAddTask.t.Fatalf("Unexpected call to ITaskQueueMock.AddTask. %v %v %v %v", ctx, payload, priority, executeAt)
	return
}

// AddTaskAfterCounter returns a count of finished ITaskQueueMock.AddTask invocations
func (mmAddTask *ITaskQueueMock) AddTaskAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTask.afterAddTaskCounter)
}

// AddTaskBeforeCounter returns a count of ITaskQueueMock.AddTask invocations
func (mmAddTask *ITaskQueueMock) AddTaskBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddTask.beforeAddTaskCounter)
}

// Calls returns a list of arguments used in each call to ITaskQueueMock.AddTask.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddTask *mITaskQueueMockAddTask) Calls() []*ITaskQueueMockAddTaskParams {
	mmAddTask.mutex.RLock()

	argCopy := make([]*ITaskQueueMockAddTaskParams, len(mmAddTask.callArgs))
	copy(argCopy, mmAddTask.callArgs)

	mmAddTask.mutex.RUnlock()

	return argCopy
}

// MinimockAddTaskDone returns true if the count of the AddTask invocations corresponds
// the number of defined expectations
func (m *ITaskQueueMock) MinimockAddTaskDone() bool {
	if m.AddTaskMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddTaskMock.invocationsDone()
}

// MinimockAddTaskInspect logs each unmet expectation
func (m *ITaskQueueMock) MinimockAddTaskInspect() {
	for _, e := range m.AddTaskMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITaskQueueMock.AddTask at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddTaskCounter := mm_atomic.LoadUint64(&m.afterAddTaskCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddTaskMock.defaultExpectation != nil && afterAddTaskCounter < 1 {
		if m.AddTaskMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITaskQueueMock.AddTask at\n%s", m.AddTaskMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITaskQueueMock.AddTask at\n%s with params: %#v", m.AddTaskMock.defaultExpectation.expectationOrigins.origin, *m.AddTaskMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddTask != nil && afterAddTaskCounter < 1 {
		m.t.Errorf("Expected call to ITaskQueueMock.AddTask at\n%s", m.funcAddTaskOrigin)
	}

	if !m.AddTaskMock.invocationsDone() && afterAddTaskCounter > 0 {
		m.t.Errorf("Expected %d calls to ITaskQueueMock.AddTask at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddTaskMock.expectedInvocations), m.AddTaskMock.expectedInvocationsOrigin, afterAddTaskCounter)
	}
}

type mITaskQueueMockProcessTasks struct {
	optional           bool
	mock               *ITaskQueueMock
	defaultExpectation *ITaskQueueMockProcessTasksExpectation
	expectations       []*ITaskQueueMockProcessTasksExpectation

	callArgs []*ITaskQueueMockProcessTasksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITaskQueueMockProcessTasksExpectation specifies expectation struct of the ITaskQueue.ProcessTasks
type ITaskQueueMockProcessTasksExpectation struct {
	mock               *ITaskQueueMock
	params             *ITaskQueueMockProcessTasksParams
	paramPtrs          *ITaskQueueMockProcessTasksParamPtrs
	expectationOrigins ITaskQueueMockProcessTasksExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// ITaskQueueMockProcessTasksParams contains parameters of the ITaskQueue.ProcessTasks
type ITaskQueueMockProcessTasksParams struct {
	ctx context.Context
}

// ITaskQueueMockProcessTasksParamPtrs contains pointers to parameters of the ITaskQueue.ProcessTasks
type ITaskQueueMockProcessTasksParamPtrs struct {
	ctx *context.Context
}

// ITaskQueueMockProcessTasksOrigins contains origins of expectations of the ITaskQueue.ProcessTasks
type ITaskQueueMockProcessTasksExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessTasks *mITaskQueueMockProcessTasks) Optional() *mITaskQueueMockProcessTasks {
	mmProcessTasks.optional = true
	return mmProcessTasks
}

// Expect sets up expected params for ITaskQueue.ProcessTasks
func (mmProcessTasks *mITaskQueueMockProcessTasks) Expect(ctx context.Context) *mITaskQueueMockProcessTasks {
	if mmProcessTasks.mock.funcProcessTasks != nil {
		mmProcessTasks.mock.t.Fatalf("ITaskQueueMock.ProcessTasks mock is already set by Set")
	}

	if mmProcessTasks.defaultExpectation == nil {
		mmProcessTasks.defaultExpectation = &ITaskQueueMockProcessTasksExpectation{}
	}

	if mmProcessTasks.defaultExpectation.paramPtrs != nil {
		mmProcessTasks.mock.t.Fatalf("ITaskQueueMock.ProcessTasks mock is already set by ExpectParams functions")
	}

	mmProcessTasks.defaultExpectation.params = &ITaskQueueMockProcessTasksParams{ctx}
	mmProcessTasks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessTasks.expectations {
		if minimock.Equal(e.params, mmProcessTasks.defaultExpectation.params) {
			mmProcessTasks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessTasks.defaultExpectation.params)
		}
	}

	return mmProcessTasks
}

// ExpectCtxParam1 sets up expected param ctx for ITaskQueue.ProcessTasks
func (mmProcessTasks *mITaskQueueMockProcessTasks) ExpectCtxParam1(ctx context.Context) *mITaskQueueMockProcessTasks {
	if mmProcessTasks.mock.funcProcessTasks != nil {
		mmProcessTasks.mock.t.Fatalf("ITaskQueueMock.ProcessTasks mock is already set by Set")
	}

	if mmProcessTasks.defaultExpectation == nil {
		mmProcessTasks.defaultExpectation = &ITaskQueueMockProcessTasksExpectation{}
	}

	if mmProcessTasks.defaultExpectation.params != nil {
		mmProcessTasks.mock.t.Fatalf("ITaskQueueMock.ProcessTasks mock is already set by Expect")
	}

	if mmProcessTasks.defaultExpectation.paramPtrs == nil {
		mmProcessTasks.defaultExpectation.paramPtrs = &ITaskQueueMockProcessTasksParamPtrs{}
	}
	mmProcessTasks.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessTasks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessTasks
}

// Inspect accepts an inspector function that has same arguments as the ITaskQueue.ProcessTasks
func (mmProcessTasks *mITaskQueueMockProcessTasks) Inspect(f func(ctx context.Context)) *mITaskQueueMockProcessTasks {
	if mmProcessTasks.mock.inspectFuncProcessTasks != nil {
		mmProcessTasks.mock.t.Fatalf("Inspect function is already set for ITaskQueueMock.ProcessTasks")
	}

	mmProcessTasks.mock.inspectFuncProcessTasks = f

	return mmProcessTasks
}

// Return sets up results that will be returned by ITaskQueue.ProcessTasks
func (mmProcessTasks *mITaskQueueMockProcessTasks) Return() *ITaskQueueMock {
	if mmProcessTasks.mock.funcProcessTasks != nil {
		mmProcessTasks.mock.t.Fatalf("ITaskQueueMock.ProcessTasks mock is already set by Set")
	}

	if mmProcessTasks.defaultExpectation == nil {
		mmProcessTasks.defaultExpectation = &ITaskQueueMockProcessTasksExpectation{mock: mmProcessTasks.mock}
	}

	mmProcessTasks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessTasks.mock
}

// Set uses given function f to mock the ITaskQueue.ProcessTasks method
func (mmProcessTasks *mITaskQueueMockProcessTasks) Set(f func(ctx context.Context)) *ITaskQueueMock {
	if mmProcessTasks.defaultExpectation != nil {
		mmProcessTasks.mock.t.Fatalf("Default expectation is already set for the ITaskQueue.ProcessTasks method")
	}

	if len(mmProcessTasks.expectations) > 0 {
		mmProcessTasks.mock.t.Fatalf("Some expectations are already set for the ITaskQueue.ProcessTasks method")
	}

	mmProcessTasks.mock.funcProcessTasks = f
	mmProcessTasks.mock.funcProcessTasksOrigin = minimock.CallerInfo(1)
	return mmProcessTasks.mock
}

// When sets expectation for the ITaskQueue.ProcessTasks which will trigger the result defined by the following
// Then helper
func (mmProcessTasks *mITaskQueueMockProcessTasks) When(ctx context.Context) *ITaskQueueMockProcessTasksExpectation {
	if mmProcessTasks.mock.funcProcessTasks != nil {
		mmProcessTasks.mock.t.Fatalf("ITaskQueueMock.ProcessTasks mock is already set by Set")
	}

	expectation := &ITaskQueueMockProcessTasksExpectation{
		mock:               mmProcessTasks.mock,
		params:             &ITaskQueueMockProcessTasksParams{ctx},
		expectationOrigins: ITaskQueueMockProcessTasksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessTasks.expectations = append(mmProcessTasks.expectations, expectation)
	return expectation
}

// Then sets up ITaskQueue.ProcessTasks return parameters for the expectation previously defined by the When method

func (e *ITaskQueueMockProcessTasksExpectation) Then() *ITaskQueueMock {
	return e.mock
}

// Times sets number of times ITaskQueue.ProcessTasks should be invoked
func (mmProcessTasks *mITaskQueueMockProcessTasks) Times(n uint64) *mITaskQueueMockProcessTasks {
	if n == 0 {
		mmProcessTasks.mock.t.Fatalf("Times of ITaskQueueMock.ProcessTasks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessTasks.expectedInvocations, n)
	mmProcessTasks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessTasks
}

func (mmProcessTasks *mITaskQueueMockProcessTasks) invocationsDone() bool {
	if len(mmProcessTasks.expectations) == 0 && mmProcessTasks.defaultExpectation == nil && mmProcessTasks.mock.funcProcessTasks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessTasks.mock.afterProcessTasksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessTasks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessTasks implements ITaskQueue
func (mmProcessTasks *ITaskQueueMock) ProcessTasks(ctx context.Context) {
	mm_atomic.AddUint64(&mmProcessTasks.beforeProcessTasksCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessTasks.afterProcessTasksCounter, 1)

	mmProcessTasks.t.Helper()

	if mmProcessTasks.inspectFuncProcessTasks != nil {
		mmProcessTasks.inspectFuncProcessTasks(ctx)
	}

	mm_params := ITaskQueueMockProcessTasksParams{ctx}

	// Record call args
	mmProcessTasks.ProcessTasksMock.mutex.Lock()
	mmProcessTasks.ProcessTasksMock.callArgs = append(mmProcessTasks.ProcessTasksMock.callArgs, &mm_params)
	mmProcessTasks.ProcessTasksMock.mutex.Unlock()

	for _, e := range mmProcessTasks.ProcessTasksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProcessTasks.ProcessTasksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessTasks.ProcessTasksMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessTasks.ProcessTasksMock.defaultExpectation.params
		mm_want_ptrs := mmProcessTasks.ProcessTasksMock.defaultExpectation.paramPtrs

		mm_got := ITaskQueueMockProcessTasksParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessTasks.t.Errorf("ITaskQueueMock.ProcessTasks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessTasks.ProcessTasksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessTasks.t.Errorf("ITaskQueueMock.ProcessTasks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessTasks.ProcessTasksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProcessTasks.funcProcessTasks != nil {
		mmProcessTasks.funcProcessTasks(ctx)
		return
	}
	mmProcessTasks.t.Fatalf("Unexpected call to ITaskQueueMock.ProcessTasks. %v", ctx)

}

// ProcessTasksAfterCounter returns a count of finished ITaskQueueMock.ProcessTasks invocations
func (mmProcessTasks *ITaskQueueMock) ProcessTasksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessTasks.afterProcessTasksCounter)
}

// ProcessTasksBeforeCounter returns a count of ITaskQueueMock.ProcessTasks invocations
func (mmProcessTasks *ITaskQueueMock) ProcessTasksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessTasks.beforeProcessTasksCounter)
}

// Calls returns a list of arguments used in each call to ITaskQueueMock.ProcessTasks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessTasks *mITaskQueueMockProcessTasks) Calls() []*ITaskQueueMockProcessTasksParams {
	mmProcessTasks.mutex.RLock()

	argCopy := make([]*ITaskQueueMockProcessTasksParams, len(mmProcessTasks.callArgs))
	copy(argCopy, mmProcessTasks.callArgs)

	mmProcessTasks.mutex.RUnlock()

	return argCopy
}

// MinimockProcessTasksDone returns true if the count of the ProcessTasks invocations corresponds
// the number of defined expectations
func (m *ITaskQueueMock) MinimockProcessTasksDone() bool {
	if m.ProcessTasksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessTasksMock.invocationsDone()
}

// MinimockProcessTasksInspect logs each unmet expectation
func (m *ITaskQueueMock) MinimockProcessTasksInspect() {
	for _, e := range m.ProcessTasksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITaskQueueMock.ProcessTasks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessTasksCounter := mm_atomic.LoadUint64(&m.afterProcessTasksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessTasksMock.defaultExpectation != nil && afterProcessTasksCounter < 1 {
		if m.ProcessTasksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITaskQueueMock.ProcessTasks at\n%s", m.ProcessTasksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITaskQueueMock.ProcessTasks at\n%s with params: %#v", m.ProcessTasksMock.defaultExpectation.expectationOrigins.origin, *m.ProcessTasksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessTasks != nil && afterProcessTasksCounter < 1 {
		m.t.Errorf("Expected call to ITaskQueueMock.ProcessTasks at\n%s", m.funcProcessTasksOrigin)
	}

	if !m.ProcessTasksMock.invocationsDone() && afterProcessTasksCounter > 0 {
		m.t.Errorf("Expected %d calls to ITaskQueueMock.ProcessTasks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessTasksMock.expectedInvocations), m.ProcessTasksMock.expectedInvocationsOrigin, afterProcessTasksCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ITaskQueueMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddTaskInspect()

			m.MinimockProcessTasksInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ITaskQueueMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ITaskQueueMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddTaskDone() &&
		m.MinimockProcessTasksDone()
}
