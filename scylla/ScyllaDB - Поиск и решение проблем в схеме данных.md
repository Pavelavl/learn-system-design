### Проблемы и причины задержек
1. **Широкие партиции**
    - **Проблема**: Все данные для одного датчика (sensor_id) хранятся в одной партиции, так как sensor_id является ключом партиции. Если датчик генерирует большое количество записей (например, данные записываются оч быстро)
    - **Причина задержек**: ScyllaDB вынуждена сканировать всю партицию при чтении данных для конкретного sensor_id. Чем больше записей, тем дольше запрос, особенно если требуется доступ к старым данным
2. **Накопление tombstone**
    - **Проблема**: Параметр default_time_to_live = (1 год) значит что записи автоматически удаляются через год. При этом gc_grace_seconds = 0 и tombstone_gc = {'mode': 'immediate', 'propagation_delay_in_seconds': '3600'} указывают на немедленное удаление данных, но с задержкой распространения изменений.
    - **Причина задержек**: После истечения TTL в партициях накапливаются tombstone. ScyllaDB должна по идее пропускать эти tombstone при чтении, что увеличивает время запросов. Отсутствие периода ожидания (gc_grace_seconds = 0) также может нарушить согласованность данных в кластере, если удаление не успевает выполнится.
3. **Неоптимальная стратегия компактирования**
    - **Описание**: Используется TimeWindowCompactionStrategy с окном в 7 дней. Эта стратегия неэффективна при высокой нагрузке или неравномерной генерации данных
    - **Причина задержек**: Если данные поступают неравномерно или в большом объеме, компактирование может не успевать оптимизировать партиции, что приводит к фрагментации и увеличению времени чтения.
4. **Ограниченная гибкость запросов**
    - **Описание**: Сортировка по timestamp DESC оптимизирована для чтения последних данных для каждого датчика. Но если приложение часто запрашивает данные за определенный период (за неделю или месяц), запросы неэффективны
    - **Причина задержек**: ScyllaDB не может эффективно фильтровать данные по временному диапазону без полного сканирования партиции, что замедляет выполнение.

### Новая схема

```cql
CREATE TABLE sensor_data (
    sensor_id text,
    bucket text,
    timestamp timestamp,
    data text,
    PRIMARY KEY ((sensor_id, bucket), timestamp)
) WITH CLUSTERING ORDER BY (timestamp DESC)
    AND bloom_filter_fp_chance = 0.01
    AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'}
    AND compaction = {'class': 'TimeWindowCompactionStrategy', 'compaction_window_size': '1', 'compaction_window_unit': 'DAYS'}
    AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'}
    AND default_time_to_live = 3153600
    AND gc_grace_seconds = 864000  -- 10 дней
    AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};
```

- Параметр compaction_window_size уменьшен с 7 до 1 дня
- Добавлено поле bucket (например, дата в формате YYYY-MM-DD)
- Установлено gc_grace_seconds = 864000 (10 дней) вместо 0, а tombstone_gc переведен в режим timeout

#### Как использовать новую схему
- При записи данных в поле bucket указывается временной интервал, например, текущая дата (2023-10-25).

